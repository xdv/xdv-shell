// File: shell_loop.ds - This file is part of XDV
// Copyright (c) 2026 Dust LLC, and Contributors
// Description:
//   Shell Loop - deterministic command buffer and dispatch.

forge ShellLoopErrors {
    const ERR_OK: UInt32 = 0;
    const ERR_READ_LINE: UInt32 = 1;
    const ERR_PARSE: UInt32 = 2;
    const ERR_EXECUTE: UInt32 = 3;
    const ERR_UNKNOWN_COMMAND: UInt32 = 4;
    const ERR_LEX: UInt32 = 5;
    const ERR_DOMAIN_NOT_AVAILABLE: UInt32 = 100;
}

forge ShellLoop {

    const MAX_LINE: UInt32 = 256;
    const MAX_CYCLES: UInt32 = 4096;
    const MAX_CMD_CHARS: UInt32 = 16;

    const RUNNING: UInt32 = 1;
    const STOPPED: UInt32 = 0;

    const CMD_NONE: UInt64 = 0;
    const CMD_CD: UInt64 = 1;
    const CMD_LS: UInt64 = 2;
    const CMD_CAT: UInt64 = 3;
    const CMD_MKDIR: UInt64 = 4;
    const CMD_RM: UInt64 = 5;
    const CMD_ECHO: UInt64 = 6;
    const CMD_PS: UInt64 = 7;
    const CMD_HELP: UInt64 = 8;
    const CMD_EXIT: UInt64 = 9;
    const CMD_EDX: UInt64 = 10;

    const CMD_UNKNOWN: UInt64 = 255;
    const CMD_TOO_LONG: UInt64 = 254;

    const TOKEN_EOF: UInt32 = 0;

    const EXEC_ERR_NOT_FOUND: UInt32 = 1;

    const PACK_LEN_FACTOR: UInt64 = 100000000000;
    const HASH_BASE: UInt64 = 131;

    const ASCII_NUL: UInt32 = 0;
    const ASCII_TAB: UInt32 = 9;
    const ASCII_LF: UInt32 = 10;
    const ASCII_CR: UInt32 = 13;
    const ASCII_SPACE: UInt32 = 32;

    const ASCII_A_LOWER: UInt32 = 97;
    const ASCII_Z_LOWER: UInt32 = 122;
    const ASCII_A_UPPER: UInt32 = 65;
    const ASCII_Z_UPPER: UInt32 = 90;
    const ASCII_CASE_DELTA: UInt32 = 32;

    proc K::run_loop() -> UInt32 {
        emit "xdv-shell: interactive loop ready";
        return run_cycles(MAX_CYCLES);
    }

    proc K::run_cycles(remaining: UInt32) -> UInt32 {
        if remaining == 0 {
            return ERR_OK;
        } else {
            render_prompt();
            let packet = read_command_packet();
            let state = process_line(packet);
            if state == STOPPED {
                return ERR_OK;
            } else {
                return run_cycles(remaining - 1);
            }
        }
    }

    proc K::process_line(packet: UInt64) -> UInt32 {
        if packet == CMD_NONE {
            return RUNNING;
        } else {
            if packet == CMD_UNKNOWN {
                print_error_unknown();
                return RUNNING;
            } else {
                if packet == CMD_TOO_LONG {
                    print_error_too_long();
                    return RUNNING;
                } else {
                    let parsed = resolve_packet_command(packet);
                    if parsed == CMD_NONE {
                        print_error_unknown();
                        return RUNNING;
                    } else {
                        let exec_result = dispatch_command(parsed, 0);
                        if exec_result == EXEC_ERR_NOT_FOUND {
                            print_error_unknown();
                            return RUNNING;
                        } else {
                            if parsed == CMD_EXIT {
                                handle_exit(exec_result);
                                return STOPPED;
                            } else {
                                return RUNNING;
                            }
                        }
                    }
                }
            }
        }
    }

    // Deterministic decode path: command packet -> lexer gate -> parser result.
    proc K::resolve_packet_command(packet: UInt64) -> UInt64 {
        let lex_result = tokenize(packet, 0);
        if lex_result == TOKEN_EOF {
            return CMD_NONE;
        } else {
            return parse(packet, 1);
        }
    }

    proc K::dispatch_command(command: UInt64, args: UInt64) -> UInt32 {
        if command == CMD_NONE {
            return ERR_PARSE;
        } else {
            return execute(command, args);
        }
    }

    proc K::handle_exit(code: UInt32) -> UInt32 {
        emit "xdv-shell: exit requested";
        cleanup();
        return code;
    }

    proc K::print_error(msg: UInt64) -> UInt32 {
        emit "xdv-shell: unknown command";
        if msg == 0 {
            putchar(10);
        } else {
            puts(msg);
        }
        return ERR_UNKNOWN_COMMAND;
    }

    proc K::print_error_unknown() -> UInt32 {
        return print_error(0);
    }

    proc K::print_error_too_long() -> UInt32 {
        emit "xdv-shell: command too long";
        putchar(10);
        return ERR_READ_LINE;
    }

    proc K::normalize_command_char(ch: UInt32) -> UInt32 {
        if ch < ASCII_A_UPPER {
            return 0;
        } else {
            if ch <= ASCII_Z_UPPER {
                return ch + ASCII_CASE_DELTA;
            } else {
                if ch < ASCII_A_LOWER {
                    return 0;
                } else {
                    if ch <= ASCII_Z_LOWER {
                        return ch;
                    } else {
                        return 0;
                    }
                }
            }
        }
    }

    proc K::hash_step(signature: UInt64, normalized_char: UInt32) -> UInt64 {
        return (signature * HASH_BASE) + normalized_char;
    }

    proc K::pack_command_packet(signature: UInt64, length: UInt32) -> UInt64 {
        if length == 0 {
            return CMD_NONE;
        } else {
            return (length * PACK_LEN_FACTOR) + signature;
        }
    }

    proc K::read_command_packet() -> UInt64 {
        return read_command_packet_state(0, 0, 0);
    }

    // done_reading_command:
    //   0 -> still reading command token
    //   1 -> command token finalized, consume remaining input until newline
    proc K::read_command_packet_state(signature: UInt64, length: UInt32, done_reading_command: UInt32) -> UInt64 {
        let ch = getchar();
        if ch == ASCII_NUL {
            if length == 0 {
                return CMD_NONE;
            } else {
                return pack_command_packet(signature, length);
            }
        } else {
            if ch == ASCII_LF {
                if length == 0 {
                    return CMD_NONE;
                } else {
                    return pack_command_packet(signature, length);
                }
            } else {
                if ch == ASCII_CR {
                    if length == 0 {
                        return CMD_NONE;
                    } else {
                        return pack_command_packet(signature, length);
                    }
                } else {
                    if ch == ASCII_SPACE {
                        if done_reading_command == 1 {
                            return read_command_packet_state(signature, length, 1);
                        } else {
                            if length == 0 {
                                return read_command_packet_state(signature, 0, 0);
                            } else {
                                return read_command_packet_state(signature, length, 1);
                            }
                        }
                    } else {
                        if ch == ASCII_TAB {
                            if done_reading_command == 1 {
                                return read_command_packet_state(signature, length, 1);
                            } else {
                                if length == 0 {
                                    return read_command_packet_state(signature, 0, 0);
                                } else {
                                    return read_command_packet_state(signature, length, 1);
                                }
                            }
                        } else {
                            if done_reading_command == 1 {
                                return read_command_packet_state(signature, length, 1);
                            } else {
                                let normalized = normalize_command_char(ch);
                                if normalized == 0 {
                                    consume_line();
                                    return CMD_UNKNOWN;
                                } else {
                                    if length < MAX_CMD_CHARS {
                                        let next_signature = hash_step(signature, normalized);
                                        return read_command_packet_state(next_signature, length + 1, 0);
                                    } else {
                                        consume_line();
                                        return CMD_TOO_LONG;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    proc K::consume_line() -> UInt32 {
        let ch = getchar();
        if ch == ASCII_NUL {
            return ERR_OK;
        } else {
            if ch == ASCII_LF {
                return ERR_OK;
            } else {
                if ch == ASCII_CR {
                    return ERR_OK;
                } else {
                    return consume_line();
                }
            }
        }
    }
}
